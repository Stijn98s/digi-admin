/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Digicatch
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AppSignUpDto
 */
export interface AppSignUpDto {
    /**
     * 
     * @type {string}
     * @memberof AppSignUpDto
     */
    name: string;
}

/**
 * 
 * @export
 * @interface Area
 */
export interface Area {
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Area
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof Area
     */
    updatedAt: string;
}

/**
 * 
 * @export
 * @interface AreaPageDto
 */
export interface AreaPageDto {
    /**
     * 
     * @type {any}
     * @memberof AreaPageDto
     */
    filter: any;
    /**
     * 
     * @type {number}
     * @memberof AreaPageDto
     */
    pageSize: number;
    /**
     * 
     * @type {number}
     * @memberof AreaPageDto
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof AreaPageDto
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Area>}
     * @memberof AreaPageDto
     */
    data: Array<Area>;
}

/**
 * 
 * @export
 * @interface CatchZone
 */
export interface CatchZone {
    /**
     * 
     * @type {string}
     * @memberof CatchZone
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CatchZone
     */
    lon: number;
    /**
     * 
     * @type {number}
     * @memberof CatchZone
     */
    lat: number;
    /**
     * 
     * @type {number}
     * @memberof CatchZone
     */
    radius: number;
    /**
     * 
     * @type {Array<Organism>}
     * @memberof CatchZone
     */
    organisms: Array<Organism>;
    /**
     * 
     * @type {Area}
     * @memberof CatchZone
     */
    area: Area;
    /**
     * 
     * @type {boolean}
     * @memberof CatchZone
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof CatchZone
     */
    updatedAt: string;
}

/**
 * 
 * @export
 * @interface CatchZonePageDto
 */
export interface CatchZonePageDto {
    /**
     * 
     * @type {any}
     * @memberof CatchZonePageDto
     */
    filter: any;
    /**
     * 
     * @type {number}
     * @memberof CatchZonePageDto
     */
    pageSize: number;
    /**
     * 
     * @type {number}
     * @memberof CatchZonePageDto
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof CatchZonePageDto
     */
    pageCount: number;
    /**
     * 
     * @type {Array<CatchZone>}
     * @memberof CatchZonePageDto
     */
    data: Array<CatchZone>;
}

/**
 * 
 * @export
 * @interface JWTDto
 */
export interface JWTDto {
    /**
     * 
     * @type {string}
     * @memberof JWTDto
     */
    jwt: string;
}

/**
 * 
 * @export
 * @interface LocalUserSchema
 */
export interface LocalUserSchema {
    /**
     * 
     * @type {string}
     * @memberof LocalUserSchema
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof LocalUserSchema
     */
    password: string;
}

/**
 * 
 * @export
 * @interface NewPlayerDto
 */
export interface NewPlayerDto {
    /**
     * 
     * @type {string}
     * @memberof NewPlayerDto
     */
    pass: string;
    /**
     * 
     * @type {string}
     * @memberof NewPlayerDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewPlayerDto
     */
    jwt: string;
}

/**
 * 
 * @export
 * @interface Organism
 */
export interface Organism {
    /**
     * 
     * @type {string}
     * @memberof Organism
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Organism
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof Organism
     */
    image: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Organism
     */
    tags: Array<Tag>;
    /**
     * 
     * @type {boolean}
     * @memberof Organism
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof Organism
     */
    updatedAt: string;
}

/**
 * 
 * @export
 * @interface OrganismPageDto
 */
export interface OrganismPageDto {
    /**
     * 
     * @type {any}
     * @memberof OrganismPageDto
     */
    filter: any;
    /**
     * 
     * @type {number}
     * @memberof OrganismPageDto
     */
    pageSize: number;
    /**
     * 
     * @type {number}
     * @memberof OrganismPageDto
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof OrganismPageDto
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Organism>}
     * @memberof OrganismPageDto
     */
    data: Array<Organism>;
}

/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    points: number;
    /**
     * 
     * @type {Array<Organism>}
     * @memberof Player
     */
    entities: Array<Organism>;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    password: string;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    deleted: boolean;
}

/**
 * 
 * @export
 * @interface PlayerPageDto
 */
export interface PlayerPageDto {
    /**
     * 
     * @type {any}
     * @memberof PlayerPageDto
     */
    filter: any;
    /**
     * 
     * @type {number}
     * @memberof PlayerPageDto
     */
    pageSize: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerPageDto
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerPageDto
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Player>}
     * @memberof PlayerPageDto
     */
    data: Array<Player>;
}

/**
 * 
 * @export
 * @interface SignInDto
 */
export interface SignInDto {
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    password: string;
}

/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    password: string;
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    points: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    color: string;
    /**
     * 
     * @type {boolean}
     * @memberof Tag
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    image: string;
}

/**
 * 
 * @export
 * @interface TagPageDto
 */
export interface TagPageDto {
    /**
     * 
     * @type {any}
     * @memberof TagPageDto
     */
    filter: any;
    /**
     * 
     * @type {number}
     * @memberof TagPageDto
     */
    pageSize: number;
    /**
     * 
     * @type {number}
     * @memberof TagPageDto
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof TagPageDto
     */
    pageCount: number;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagPageDto
     */
    data: Array<Tag>;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role: User.RoleEnum;
    /**
     * 
     * @type {LocalUserSchema}
     * @memberof User
     */
    local: LocalUserSchema;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt: string;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        Admin = <any> 'admin',
        User = <any> 'user'
    }
}

/**
 * 
 * @export
 * @interface UserPageDto
 */
export interface UserPageDto {
    /**
     * 
     * @type {any}
     * @memberof UserPageDto
     */
    filter: any;
    /**
     * 
     * @type {number}
     * @memberof UserPageDto
     */
    pageSize: number;
    /**
     * 
     * @type {number}
     * @memberof UserPageDto
     */
    page: number;
    /**
     * 
     * @type {number}
     * @memberof UserPageDto
     */
    pageCount: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPageDto
     */
    data: Array<User>;
}


/**
 * AreasApi - fetch parameter creator
 * @export
 */
export const AreasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/areas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter.join(COLLECTION_FORMATS["csv"]);
            }

            if (include) {
                localVarQueryParameter['include'] = include.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling areasIdDelete.');
            }
            const localVarPath = `/areas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling areasIdGet.');
            }
            const localVarPath = `/areas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Area} area 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdPut(area: Area, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'area' is not null or undefined
            if (area === null || area === undefined) {
                throw new RequiredError('area','Required parameter area was null or undefined when calling areasIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling areasIdPut.');
            }
            const localVarPath = `/areas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Area" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(area || {}) : (area || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Area} area 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasPost(area: Area, options: any = {}): FetchArgs {
            // verify required parameter 'area' is not null or undefined
            if (area === null || area === undefined) {
                throw new RequiredError('area','Required parameter area was null or undefined when calling areasPost.');
            }
            const localVarPath = `/areas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Area" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(area || {}) : (area || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AreasApi - functional programming interface
 * @export
 */
export const AreasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AreaPageDto> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasGet(page, pageSize, filter, include, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Area} area 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdPut(area: Area, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasIdPut(area, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Area} area 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasPost(area: Area, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
            const localVarFetchArgs = AreasApiFetchParamCreator(configuration).areasPost(area, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AreasApi - factory interface
 * @export
 */
export const AreasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
            return AreasApiFp(configuration).areasGet(page, pageSize, filter, include, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdDelete(id: string, options?: any) {
            return AreasApiFp(configuration).areasIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdGet(id: string, options?: any) {
            return AreasApiFp(configuration).areasIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Area} area 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasIdPut(area: Area, id: string, options?: any) {
            return AreasApiFp(configuration).areasIdPut(area, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Area} area 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areasPost(area: Area, options?: any) {
            return AreasApiFp(configuration).areasPost(area, options)(fetch, basePath);
        },
    };
};

/**
 * AreasApi - interface
 * @export
 * @interface AreasApi
 */
export interface AreasApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApiInterface
     */
    areasGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): Promise<AreaPageDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApiInterface
     */
    areasIdDelete(id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApiInterface
     */
    areasIdGet(id: string, options?: any): Promise<Area>;

    /**
     * 
     * @param {Area} area 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApiInterface
     */
    areasIdPut(area: Area, id: string, options?: any): Promise<Area>;

    /**
     * 
     * @param {Area} area 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApiInterface
     */
    areasPost(area: Area, options?: any): Promise<Area>;

}

/**
 * AreasApi - object-oriented interface
 * @export
 * @class AreasApi
 * @extends {BaseAPI}
 */
export class AreasApi extends BaseAPI implements AreasApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
        return AreasApiFp(this.configuration).areasGet(page, pageSize, filter, include, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasIdDelete(id: string, options?: any) {
        return AreasApiFp(this.configuration).areasIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasIdGet(id: string, options?: any) {
        return AreasApiFp(this.configuration).areasIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Area} area 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasIdPut(area: Area, id: string, options?: any) {
        return AreasApiFp(this.configuration).areasIdPut(area, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Area} area 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AreasApi
     */
    public areasPost(area: Area, options?: any) {
        return AreasApiFp(this.configuration).areasPost(area, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApplocalPost(signInDto: SignInDto, options: any = {}): FetchArgs {
            // verify required parameter 'signInDto' is not null or undefined
            if (signInDto === null || signInDto === undefined) {
                throw new RequiredError('signInDto','Required parameter signInDto was null or undefined when calling authApplocalPost.');
            }
            const localVarPath = `/auth/applocal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignInDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(signInDto || {}) : (signInDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AppSignUpDto} appSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAppsignupPost(appSignUpDto: AppSignUpDto, options: any = {}): FetchArgs {
            // verify required parameter 'appSignUpDto' is not null or undefined
            if (appSignUpDto === null || appSignUpDto === undefined) {
                throw new RequiredError('appSignUpDto','Required parameter appSignUpDto was null or undefined when calling authAppsignupPost.');
            }
            const localVarPath = `/auth/appsignup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AppSignUpDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(appSignUpDto || {}) : (appSignUpDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalPost(signUpDto: SignUpDto, options: any = {}): FetchArgs {
            // verify required parameter 'signUpDto' is not null or undefined
            if (signUpDto === null || signUpDto === undefined) {
                throw new RequiredError('signUpDto','Required parameter signUpDto was null or undefined when calling authLocalPost.');
            }
            const localVarPath = `/auth/local`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignUpDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(signUpDto || {}) : (signUpDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProtectedGet(options: any = {}): FetchArgs {
            const localVarPath = `/auth/protected`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApplocalPost(signInDto: SignInDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JWTDto> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).authApplocalPost(signInDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AppSignUpDto} appSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAppsignupPost(appSignUpDto: AppSignUpDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NewPlayerDto> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).authAppsignupPost(appSignUpDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalPost(signUpDto: SignUpDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JWTDto> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).authLocalPost(signUpDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProtectedGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).authProtectedGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApplocalPost(signInDto: SignInDto, options?: any) {
            return AuthenticationApiFp(configuration).authApplocalPost(signInDto, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AppSignUpDto} appSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authAppsignupPost(appSignUpDto: AppSignUpDto, options?: any) {
            return AuthenticationApiFp(configuration).authAppsignupPost(appSignUpDto, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLocalPost(signUpDto: SignUpDto, options?: any) {
            return AuthenticationApiFp(configuration).authLocalPost(signUpDto, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProtectedGet(options?: any) {
            return AuthenticationApiFp(configuration).authProtectedGet(options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authApplocalPost(signInDto: SignInDto, options?: any): Promise<JWTDto>;

    /**
     * 
     * @param {AppSignUpDto} appSignUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authAppsignupPost(appSignUpDto: AppSignUpDto, options?: any): Promise<NewPlayerDto>;

    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authLocalPost(signUpDto: SignUpDto, options?: any): Promise<JWTDto>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authProtectedGet(options?: any): Promise<{}>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authApplocalPost(signInDto: SignInDto, options?: any) {
        return AuthenticationApiFp(this.configuration).authApplocalPost(signInDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AppSignUpDto} appSignUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authAppsignupPost(appSignUpDto: AppSignUpDto, options?: any) {
        return AuthenticationApiFp(this.configuration).authAppsignupPost(appSignUpDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authLocalPost(signUpDto: SignUpDto, options?: any) {
        return AuthenticationApiFp(this.configuration).authLocalPost(signUpDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authProtectedGet(options?: any) {
        return AuthenticationApiFp(this.configuration).authProtectedGet(options)(this.fetch, this.basePath);
    }

}

/**
 * CatchzonesApi - fetch parameter creator
 * @export
 */
export const CatchzonesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/catchzones`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter.join(COLLECTION_FORMATS["csv"]);
            }

            if (include) {
                localVarQueryParameter['include'] = include.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling catchzonesIdDelete.');
            }
            const localVarPath = `/catchzones/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling catchzonesIdGet.');
            }
            const localVarPath = `/catchzones/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CatchZone} catchZone 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdPut(catchZone: CatchZone, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'catchZone' is not null or undefined
            if (catchZone === null || catchZone === undefined) {
                throw new RequiredError('catchZone','Required parameter catchZone was null or undefined when calling catchzonesIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling catchzonesIdPut.');
            }
            const localVarPath = `/catchzones/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatchZone" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catchZone || {}) : (catchZone || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CatchZone} catchZone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesPost(catchZone: CatchZone, options: any = {}): FetchArgs {
            // verify required parameter 'catchZone' is not null or undefined
            if (catchZone === null || catchZone === undefined) {
                throw new RequiredError('catchZone','Required parameter catchZone was null or undefined when calling catchzonesPost.');
            }
            const localVarPath = `/catchzones`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CatchZone" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(catchZone || {}) : (catchZone || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatchzonesApi - functional programming interface
 * @export
 */
export const CatchzonesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatchZonePageDto> {
            const localVarFetchArgs = CatchzonesApiFetchParamCreator(configuration).catchzonesGet(page, pageSize, filter, include, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatchzonesApiFetchParamCreator(configuration).catchzonesIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatchZone> {
            const localVarFetchArgs = CatchzonesApiFetchParamCreator(configuration).catchzonesIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CatchZone} catchZone 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdPut(catchZone: CatchZone, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatchZone> {
            const localVarFetchArgs = CatchzonesApiFetchParamCreator(configuration).catchzonesIdPut(catchZone, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CatchZone} catchZone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesPost(catchZone: CatchZone, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatchZone> {
            const localVarFetchArgs = CatchzonesApiFetchParamCreator(configuration).catchzonesPost(catchZone, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatchzonesApi - factory interface
 * @export
 */
export const CatchzonesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
            return CatchzonesApiFp(configuration).catchzonesGet(page, pageSize, filter, include, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdDelete(id: string, options?: any) {
            return CatchzonesApiFp(configuration).catchzonesIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdGet(id: string, options?: any) {
            return CatchzonesApiFp(configuration).catchzonesIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CatchZone} catchZone 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesIdPut(catchZone: CatchZone, id: string, options?: any) {
            return CatchzonesApiFp(configuration).catchzonesIdPut(catchZone, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CatchZone} catchZone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzonesPost(catchZone: CatchZone, options?: any) {
            return CatchzonesApiFp(configuration).catchzonesPost(catchZone, options)(fetch, basePath);
        },
    };
};

/**
 * CatchzonesApi - interface
 * @export
 * @interface CatchzonesApi
 */
export interface CatchzonesApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApiInterface
     */
    catchzonesGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): Promise<CatchZonePageDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApiInterface
     */
    catchzonesIdDelete(id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApiInterface
     */
    catchzonesIdGet(id: string, options?: any): Promise<CatchZone>;

    /**
     * 
     * @param {CatchZone} catchZone 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApiInterface
     */
    catchzonesIdPut(catchZone: CatchZone, id: string, options?: any): Promise<CatchZone>;

    /**
     * 
     * @param {CatchZone} catchZone 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApiInterface
     */
    catchzonesPost(catchZone: CatchZone, options?: any): Promise<CatchZone>;

}

/**
 * CatchzonesApi - object-oriented interface
 * @export
 * @class CatchzonesApi
 * @extends {BaseAPI}
 */
export class CatchzonesApi extends BaseAPI implements CatchzonesApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApi
     */
    public catchzonesGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
        return CatchzonesApiFp(this.configuration).catchzonesGet(page, pageSize, filter, include, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApi
     */
    public catchzonesIdDelete(id: string, options?: any) {
        return CatchzonesApiFp(this.configuration).catchzonesIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApi
     */
    public catchzonesIdGet(id: string, options?: any) {
        return CatchzonesApiFp(this.configuration).catchzonesIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CatchZone} catchZone 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApi
     */
    public catchzonesIdPut(catchZone: CatchZone, id: string, options?: any) {
        return CatchzonesApiFp(this.configuration).catchzonesIdPut(catchZone, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CatchZone} catchZone 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatchzonesApi
     */
    public catchzonesPost(catchZone: CatchZone, options?: any) {
        return CatchzonesApiFp(this.configuration).catchzonesPost(catchZone, options)(this.fetch, this.basePath);
    }

}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).rootGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any) {
            return DefaultApiFp(configuration).rootGet(options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    rootGet(options?: any): Promise<{}>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: any) {
        return DefaultApiFp(this.configuration).rootGet(options)(this.fetch, this.basePath);
    }

}

/**
 * IncrementalApi - fetch parameter creator
 * @export
 */
export const IncrementalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areaGet(date: string, options: any = {}): FetchArgs {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling areaGet.');
            }
            const localVarPath = `/area`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzoneGet(date: string, options: any = {}): FetchArgs {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling catchzoneGet.');
            }
            const localVarPath = `/catchzone`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismGet(date: string, options: any = {}): FetchArgs {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling organismGet.');
            }
            const localVarPath = `/organism`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGet(date: string, options: any = {}): FetchArgs {
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling tagGet.');
            }
            const localVarPath = `/tag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncrementalApi - functional programming interface
 * @export
 */
export const IncrementalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areaGet(date: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Area>> {
            const localVarFetchArgs = IncrementalApiFetchParamCreator(configuration).areaGet(date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzoneGet(date: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CatchZone>> {
            const localVarFetchArgs = IncrementalApiFetchParamCreator(configuration).catchzoneGet(date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismGet(date: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Organism>> {
            const localVarFetchArgs = IncrementalApiFetchParamCreator(configuration).organismGet(date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGet(date: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tag>> {
            const localVarFetchArgs = IncrementalApiFetchParamCreator(configuration).tagGet(date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IncrementalApi - factory interface
 * @export
 */
export const IncrementalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        areaGet(date: string, options?: any) {
            return IncrementalApiFp(configuration).areaGet(date, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catchzoneGet(date: string, options?: any) {
            return IncrementalApiFp(configuration).catchzoneGet(date, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismGet(date: string, options?: any) {
            return IncrementalApiFp(configuration).organismGet(date, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGet(date: string, options?: any) {
            return IncrementalApiFp(configuration).tagGet(date, options)(fetch, basePath);
        },
    };
};

/**
 * IncrementalApi - interface
 * @export
 * @interface IncrementalApi
 */
export interface IncrementalApiInterface {
    /**
     * 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncrementalApiInterface
     */
    areaGet(date: string, options?: any): Promise<Array<Area>>;

    /**
     * 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncrementalApiInterface
     */
    catchzoneGet(date: string, options?: any): Promise<Array<CatchZone>>;

    /**
     * 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncrementalApiInterface
     */
    organismGet(date: string, options?: any): Promise<Array<Organism>>;

    /**
     * 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncrementalApiInterface
     */
    tagGet(date: string, options?: any): Promise<Array<Tag>>;

}

/**
 * IncrementalApi - object-oriented interface
 * @export
 * @class IncrementalApi
 * @extends {BaseAPI}
 */
export class IncrementalApi extends BaseAPI implements IncrementalApiInterface {
    /**
     * 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncrementalApi
     */
    public areaGet(date: string, options?: any) {
        return IncrementalApiFp(this.configuration).areaGet(date, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncrementalApi
     */
    public catchzoneGet(date: string, options?: any) {
        return IncrementalApiFp(this.configuration).catchzoneGet(date, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncrementalApi
     */
    public organismGet(date: string, options?: any) {
        return IncrementalApiFp(this.configuration).organismGet(date, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncrementalApi
     */
    public tagGet(date: string, options?: any) {
        return IncrementalApiFp(this.configuration).tagGet(date, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganismsApi - fetch parameter creator
 * @export
 */
export const OrganismsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/organisms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter.join(COLLECTION_FORMATS["csv"]);
            }

            if (include) {
                localVarQueryParameter['include'] = include.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling organismsIdDelete.');
            }
            const localVarPath = `/organisms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling organismsIdGet.');
            }
            const localVarPath = `/organisms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Organism} organism 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdPut(organism: Organism, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organism' is not null or undefined
            if (organism === null || organism === undefined) {
                throw new RequiredError('organism','Required parameter organism was null or undefined when calling organismsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling organismsIdPut.');
            }
            const localVarPath = `/organisms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organism" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(organism || {}) : (organism || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Organism} organism 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsPost(organism: Organism, options: any = {}): FetchArgs {
            // verify required parameter 'organism' is not null or undefined
            if (organism === null || organism === undefined) {
                throw new RequiredError('organism','Required parameter organism was null or undefined when calling organismsPost.');
            }
            const localVarPath = `/organisms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organism" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(organism || {}) : (organism || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganismsApi - functional programming interface
 * @export
 */
export const OrganismsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganismPageDto> {
            const localVarFetchArgs = OrganismsApiFetchParamCreator(configuration).organismsGet(page, pageSize, filter, include, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganismsApiFetchParamCreator(configuration).organismsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organism> {
            const localVarFetchArgs = OrganismsApiFetchParamCreator(configuration).organismsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Organism} organism 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdPut(organism: Organism, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganismsApiFetchParamCreator(configuration).organismsIdPut(organism, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Organism} organism 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsPost(organism: Organism, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganismsApiFetchParamCreator(configuration).organismsPost(organism, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganismsApi - factory interface
 * @export
 */
export const OrganismsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
            return OrganismsApiFp(configuration).organismsGet(page, pageSize, filter, include, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdDelete(id: string, options?: any) {
            return OrganismsApiFp(configuration).organismsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdGet(id: string, options?: any) {
            return OrganismsApiFp(configuration).organismsIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Organism} organism 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsIdPut(organism: Organism, id: string, options?: any) {
            return OrganismsApiFp(configuration).organismsIdPut(organism, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Organism} organism 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organismsPost(organism: Organism, options?: any) {
            return OrganismsApiFp(configuration).organismsPost(organism, options)(fetch, basePath);
        },
    };
};

/**
 * OrganismsApi - interface
 * @export
 * @interface OrganismsApi
 */
export interface OrganismsApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApiInterface
     */
    organismsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): Promise<OrganismPageDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApiInterface
     */
    organismsIdDelete(id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApiInterface
     */
    organismsIdGet(id: string, options?: any): Promise<Organism>;

    /**
     * 
     * @param {Organism} organism 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApiInterface
     */
    organismsIdPut(organism: Organism, id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {Organism} organism 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApiInterface
     */
    organismsPost(organism: Organism, options?: any): Promise<{}>;

}

/**
 * OrganismsApi - object-oriented interface
 * @export
 * @class OrganismsApi
 * @extends {BaseAPI}
 */
export class OrganismsApi extends BaseAPI implements OrganismsApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApi
     */
    public organismsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
        return OrganismsApiFp(this.configuration).organismsGet(page, pageSize, filter, include, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApi
     */
    public organismsIdDelete(id: string, options?: any) {
        return OrganismsApiFp(this.configuration).organismsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApi
     */
    public organismsIdGet(id: string, options?: any) {
        return OrganismsApiFp(this.configuration).organismsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Organism} organism 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApi
     */
    public organismsIdPut(organism: Organism, id: string, options?: any) {
        return OrganismsApiFp(this.configuration).organismsIdPut(organism, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Organism} organism 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganismsApi
     */
    public organismsPost(organism: Organism, options?: any) {
        return OrganismsApiFp(this.configuration).organismsPost(organism, options)(this.fetch, this.basePath);
    }

}

/**
 * PlayersApi - fetch parameter creator
 * @export
 */
export const PlayersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/players`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter.join(COLLECTION_FORMATS["csv"]);
            }

            if (include) {
                localVarQueryParameter['include'] = include.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playersIdDelete.');
            }
            const localVarPath = `/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playersIdGet.');
            }
            const localVarPath = `/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Player} player 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdPut(player: Player, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'player' is not null or undefined
            if (player === null || player === undefined) {
                throw new RequiredError('player','Required parameter player was null or undefined when calling playersIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playersIdPut.');
            }
            const localVarPath = `/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Player" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(player || {}) : (player || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Player} player 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersPost(player: Player, options: any = {}): FetchArgs {
            // verify required parameter 'player' is not null or undefined
            if (player === null || player === undefined) {
                throw new RequiredError('player','Required parameter player was null or undefined when calling playersPost.');
            }
            const localVarPath = `/players`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Player" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(player || {}) : (player || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerPageDto> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersGet(page, pageSize, filter, include, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Player} player 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdPut(player: Player, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersIdPut(player, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Player} player 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersPost(player: Player, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersPost(player, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
            return PlayersApiFp(configuration).playersGet(page, pageSize, filter, include, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdDelete(id: string, options?: any) {
            return PlayersApiFp(configuration).playersIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdGet(id: string, options?: any) {
            return PlayersApiFp(configuration).playersIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Player} player 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdPut(player: Player, id: string, options?: any) {
            return PlayersApiFp(configuration).playersIdPut(player, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Player} player 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersPost(player: Player, options?: any) {
            return PlayersApiFp(configuration).playersPost(player, options)(fetch, basePath);
        },
    };
};

/**
 * PlayersApi - interface
 * @export
 * @interface PlayersApi
 */
export interface PlayersApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApiInterface
     */
    playersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): Promise<PlayerPageDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApiInterface
     */
    playersIdDelete(id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApiInterface
     */
    playersIdGet(id: string, options?: any): Promise<Player>;

    /**
     * 
     * @param {Player} player 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApiInterface
     */
    playersIdPut(player: Player, id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {Player} player 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApiInterface
     */
    playersPost(player: Player, options?: any): Promise<{}>;

}

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI implements PlayersApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
        return PlayersApiFp(this.configuration).playersGet(page, pageSize, filter, include, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersIdDelete(id: string, options?: any) {
        return PlayersApiFp(this.configuration).playersIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersIdGet(id: string, options?: any) {
        return PlayersApiFp(this.configuration).playersIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Player} player 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersIdPut(player: Player, id: string, options?: any) {
        return PlayersApiFp(this.configuration).playersIdPut(player, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Player} player 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersPost(player: Player, options?: any) {
        return PlayersApiFp(this.configuration).playersPost(player, options)(this.fetch, this.basePath);
    }

}

/**
 * TagsApi - fetch parameter creator
 * @export
 */
export const TagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter.join(COLLECTION_FORMATS["csv"]);
            }

            if (include) {
                localVarQueryParameter['include'] = include.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagsIdDelete.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagsIdGet.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdPut(tag: Tag, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling tagsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagsIdPut.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tag || {}) : (tag || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(tag: Tag, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling tagsPost.');
            }
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tag || {}) : (tag || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TagPageDto> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsGet(page, pageSize, filter, include, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdPut(tag: Tag, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsIdPut(tag, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(tag: Tag, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagsPost(tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
            return TagsApiFp(configuration).tagsGet(page, pageSize, filter, include, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdDelete(id: string, options?: any) {
            return TagsApiFp(configuration).tagsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdGet(id: string, options?: any) {
            return TagsApiFp(configuration).tagsIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsIdPut(tag: Tag, id: string, options?: any) {
            return TagsApiFp(configuration).tagsIdPut(tag, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(tag: Tag, options?: any) {
            return TagsApiFp(configuration).tagsPost(tag, options)(fetch, basePath);
        },
    };
};

/**
 * TagsApi - interface
 * @export
 * @interface TagsApi
 */
export interface TagsApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): Promise<TagPageDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsIdDelete(id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsIdGet(id: string, options?: any): Promise<Tag>;

    /**
     * 
     * @param {Tag} tag 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsIdPut(tag: Tag, id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    tagsPost(tag: Tag, options?: any): Promise<{}>;

}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI implements TagsApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
        return TagsApiFp(this.configuration).tagsGet(page, pageSize, filter, include, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsIdDelete(id: string, options?: any) {
        return TagsApiFp(this.configuration).tagsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsIdGet(id: string, options?: any) {
        return TagsApiFp(this.configuration).tagsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Tag} tag 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsIdPut(tag: Tag, id: string, options?: any) {
        return TagsApiFp(this.configuration).tagsIdPut(tag, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPost(tag: Tag, options?: any) {
        return TagsApiFp(this.configuration).tagsPost(tag, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter.join(COLLECTION_FORMATS["csv"]);
            }

            if (include) {
                localVarQueryParameter['include'] = include.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdDelete.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdGet.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} user 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(user: User, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling usersIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdPut.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(signUpDto: SignUpDto, options: any = {}): FetchArgs {
            // verify required parameter 'signUpDto' is not null or undefined
            if (signUpDto === null || signUpDto === undefined) {
                throw new RequiredError('signUpDto','Required parameter signUpDto was null or undefined when calling usersPost.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignUpDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(signUpDto || {}) : (signUpDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPageDto> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersGet(page, pageSize, filter, include, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {User} user 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(user: User, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersIdPut(user, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(signUpDto: SignUpDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersPost(signUpDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
         * @param {Array<string>} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
            return UsersApiFp(configuration).usersGet(page, pageSize, filter, include, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options?: any) {
            return UsersApiFp(configuration).usersIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: any) {
            return UsersApiFp(configuration).usersIdGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {User} user 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(user: User, id: string, options?: any) {
            return UsersApiFp(configuration).usersIdPut(user, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(signUpDto: SignUpDto, options?: any) {
            return UsersApiFp(configuration).usersPost(signUpDto, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any): Promise<UserPageDto>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersIdDelete(id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersIdGet(id: string, options?: any): Promise<User>;

    /**
     * 
     * @param {User} user 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersIdPut(user: User, id: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersPost(signUpDto: SignUpDto, options?: any): Promise<User>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {Array<string>} [filter] pass in field:value field is a field on the model, value is string contained in the property of the model
     * @param {Array<string>} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(page?: number, pageSize?: number, filter?: Array<string>, include?: Array<string>, options?: any) {
        return UsersApiFp(this.configuration).usersGet(page, pageSize, filter, include, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdDelete(id: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdGet(id: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {User} user 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdPut(user: User, id: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdPut(user, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(signUpDto: SignUpDto, options?: any) {
        return UsersApiFp(this.configuration).usersPost(signUpDto, options)(this.fetch, this.basePath);
    }

}

